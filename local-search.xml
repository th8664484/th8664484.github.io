<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二分查找算法</title>
    <link href="/2023/02/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><p class="note note-secondary"><em>二分查找框架</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>,right =...;<br>    <span class="hljs-keyword">while</span>(...)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left+(right-left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            ...<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[min] &lt; target)&#123;<br>            ...<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[min] &gt; targetn)&#123;<br>            ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>注意：</strong><br>代码中 <code>left+(right - left) / 2</code> 和 <code>(left+right) / 2</code> 的结果相同，防止 <code>left</code> 和 <code>right</code> 太大，导致益处问题。</p><p class="note note-secondary"><em>基本的二分搜索</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = nums.length -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right )&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left +(right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">//注意</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//注意</span><br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="为什么-while-循环的条件的-lt-而不是-lt"><a href="#为什么-while-循环的条件的-lt-而不是-lt" class="headerlink" title="为什么 while 循环的条件的 &lt;=,而不是 &lt; ?"></a>为什么 <code>while</code> 循环的条件的 <code>&lt;=</code>,而不是 <code>&lt;</code> ?</h6><p>因为初始化 <code>right = nums.length -1</code>,而不是 <code>nums.lenght</code></p><ul><li><p><code>while(left&lt;= right)</code> 的终止条件是 <code>left = right+1</code> , 区间形式 <code>[right+1,right]</code></p></li><li><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code> , 区间形式 <code>[right,right]</code></p></li></ul><p><strong>注意：</strong> 使用<code>while(left &lt; right)</code>,返沪值要特殊处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(...)&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h6 id="为什么-left-mid-1-right-mid-1-有的是-right-mid-left-mid"><a href="#为什么-left-mid-1-right-mid-1-有的是-right-mid-left-mid" class="headerlink" title="为什么 left = mid + 1 , right = mid - 1 .有的是 right = mid ,left = mid ?"></a>为什么 <code>left = mid + 1</code> , <code>right = mid - 1</code> .有的是 <code>right = mid</code> ,<code>left = mid</code> ?</h6><p>因为 <strong>「搜索区间」</strong> 的不同，导致要计算的边界也不相同。</p><p class="note note-secondary"><em>寻找左侧边界的二分搜索</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length; <span class="hljs-comment">//注意</span><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123; <span class="hljs-comment">//注意</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left ) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            right = mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid ; <span class="hljs-comment">//注意</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="为什么-while-中的是-lt-而不是-lt"><a href="#为什么-while-中的是-lt-而不是-lt" class="headerlink" title="为什么 while 中的是 &lt; 而不是 &lt;= ?"></a>为什么 while 中的是 <code>&lt;</code> 而不是 <code>&lt;=</code> ?</h6><p>因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code><br><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code></p><h6 id="为什么没有返回-1-的操作？如果-nums-中不存在-target-这个值，怎么办"><a href="#为什么没有返回-1-的操作？如果-nums-中不存在-target-这个值，怎么办" class="headerlink" title="为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办 ?"></a>为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办 ?</h6><p>在返回的时候额外判断一下 <code>nums[left]</code> 是否等于 <code>target</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>    ...<br>&#125;<br><span class="hljs-comment">// 此时，target 比所有数都大，返回 -1</span><br><span class="hljs-keyword">if</span>(left == nums.length)&#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//判断 nums[left] 是不是 target</span><br><span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><h6 id="为什么该算法能够搜索左侧边界"><a href="#为什么该算法能够搜索左侧边界" class="headerlink" title="为什么该算法能够搜索左侧边界 ?"></a>为什么该算法能够搜索左侧边界 ?</h6><p>关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] == target)<br>   right = mid;<br></code></pre></td></tr></table></figure><h6 id="为什么返回-left-而不是-right"><a href="#为什么返回-left-而不是-right" class="headerlink" title="为什么返回 left 而不是 right ?"></a>为什么返回 <code>left</code> 而不是 <code>right</code> ?</h6><p>都是一样的，因为 <code>while</code> 终止的条件是 <code>left == right</code>。</p><h6 id="把-right-变成-nums-length-1"><a href="#把-right-变成-nums-length-1" class="headerlink" title="把 right 变成 nums.length - 1"></a>把 <code>right</code> 变成 <code>nums.length - 1</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length-<span class="hljs-number">1</span>; <span class="hljs-comment">//注意</span><br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123; <span class="hljs-comment">//注意</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left ) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 收缩右侧边界</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123; <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123; <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//注意</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( left == nums.length)&#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure> <p class="note note-secondary"><em>寻找右侧边界的二分搜索</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length; <span class="hljs-comment">//注意</span><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123; <span class="hljs-comment">//注意</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left ) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid; <span class="hljs-comment">//注意</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="为什么这个算法能够找到右侧边界"><a href="#为什么这个算法能够找到右侧边界" class="headerlink" title="为什么这个算法能够找到右侧边界"></a>为什么这个算法能够找到右侧边界</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>  left = mid + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的左边界 <code>left</code>，使得区间不断向右靠拢，达到锁定右侧边界的目的。</p><h6 id="为什么返回-left-1-而不是-right"><a href="#为什么返回-left-1-而不是-right" class="headerlink" title="为什么返回 left - 1 而不是 right"></a>为什么返回 <code>left - 1</code> 而不是 <code>right</code></h6><p>首先，<code>while</code> 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，非要体现右侧的特点，返回 <code>right - 1</code> 。</p><img src="https://labuladong.github.io/algo/images/%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be/3.jpg"><h6 id="返回-1-的操作-如果-nums-中不存在-target"><a href="#返回-1-的操作-如果-nums-中不存在-target" class="headerlink" title="返回 -1 的操作,如果 nums 中不存在 target"></a>返回 -1 的操作,如果 nums 中不存在 target</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>  ...<br>&#125;<br><span class="hljs-comment">//判断target 是否存在于nums中</span><br><span class="hljs-comment">//此时 left-1 索引越界</span><br><span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 判断 nums[left-1] 是不是target</span><br><span class="hljs-keyword">return</span> nums[left-<span class="hljs-number">1</span>] == target ? (left - <span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h6 id="把-right-变成-nums-length-1-1"><a href="#把-right-变成-nums-length-1-1" class="headerlink" title="把 right 变成 nums.length - 1"></a>把 <code>right</code> 变成 <code>nums.length - 1</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length-<span class="hljs-number">1</span>; <span class="hljs-comment">//注意</span><br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123; <span class="hljs-comment">//注意</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left ) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//注意</span><br>        &#125;<br>    &#125;<br>     <span class="hljs-comment">// 最后改成返回 left - 1</span><br>    <span class="hljs-keyword">if</span> (left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? (left - <span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure> <p class="note note-secondary"><em>逻辑统一</em></p><ul><li><strong>第一个，最基本的二分查找算法</strong></li></ul><p>因为我们初始化 <code>right = nums.length - 1</code><br>所以决定了我们的「搜索区间」是 <code>[left, right]</code><br>所以决定了 <code>while (left &lt;= right)</code><br>同时也决定了 <code>left = mid+1</code> 和 <code>right = mid-1</code><br>因为我们只需找到一个 target 的索引即可<br>所以当 <code>nums[mid] == target</code> 时可以立即返回</p><ul><li><strong>第二个，寻找左侧边界的二分查找</strong></li></ul><p>因为我们初始化 <code>right = nums.length</code><br>所以决定了我们的「搜索区间」是 <code>[left, right)</code><br>所以决定了 <code>while (left &lt; right)</code><br>同时也决定了 <code>left = mid + 1</code> 和 <code>right = mid</code></p><p>因为我们需找到 target 的最左侧索引<br>所以当 <code>nums[mid] == target</code> 时不要立即返回<br>而要收紧右侧边界以锁定左侧边界</p><ul><li><strong>第三个，寻找右侧边界的二分查找</strong></li></ul><p>因为我们初始化 <code>right = nums.length</code><br>所以决定了我们的「搜索区间」是 <code>[left, right)</code><br>所以决定了 <code>while (left &lt; right)</code><br>同时也决定了 <code>left = mid + 1</code> 和 <code>right = mid</code></p><p>因为我们需找到 target 的最右侧索引<br>所以当 <code>nums[mid] == target</code> 时不要立即返回<br>而要收紧左侧边界以锁定右侧边界</p><p>又因为收紧左侧边界时必须 <code>left = mid + 1</code><br>所以最后无论返回 <code>left </code>还是 <code>right</code>，必须减一</p><ul><li><strong>第四个，统一成了两端都闭</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 直接返回</span><br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 直接返回</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定左侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断 target 是否存在于 nums 中</span><br>    <span class="hljs-comment">// 此时 target 比所有数都大，返回 -1</span><br>    <span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定右侧边界</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 此时 left - 1 索引越界</span><br>    <span class="hljs-keyword">if</span> (left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? (left - <span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></div>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组算法技巧</title>
    <link href="/2023/02/10/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/02/10/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><p class="note note-secondary"> <em>认识数组</em></p><p>目前正在 <span class="label label-primary">labuladong</span>的网站下学习数据结构和算法 <strong>————</strong> 链表。<br><code>左右指针</code>和<code>快慢指针</code></p><p><a class="btn" href="https://labuladong.github.io/algo/">博客</a></p><p class="note note-secondary"> <em>快慢指针技巧</em></p><h6 id="有序数组去重"><a href="#有序数组去重" class="headerlink" title="有序数组去重"></a>有序数组去重</h6><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/title.png">用到快慢指针技巧：<p>我们让慢指针 <code>slow</code> 走在后面，快指针 <code>fast</code> 走在前面探路，找到一个不重复的元素就赋值给 <code>slow</code> 并让 <code>slow</code> 前进一步。</p><p>这样，就保证了 <code>nums[0..slow]</code> 都是无重复的元素，当 <code>fast</code> 指针遍历完整个数组 <code>nums</code> 后，<code>nums[0..slow]</code> 就是整个数组去重之后的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast] != nums[slow])&#123;<br>            slow++;<br>            <span class="hljs-comment">//维护 nums[0..slow] 无重复</span><br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-comment">//数组长度为索引 + 1</span><br>    <span class="hljs-keyword">return</span> slow+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法执行过程：<br><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/1.gif"></p><h6 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head,fast = head;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(fast.val != slow.val)&#123;<br>            slow.next = fast; <span class="hljs-comment">//nums[slow] = nums[fast];</span><br>            slow = slow.next; <span class="hljs-comment">//slow++;</span><br>        &#125;<br>        fast = fast.next; <span class="hljs-comment">//fast++</span><br>    &#125;<br>    slow.next = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法执行过程:<br><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/2.gif"></p><h6 id="有序数组-x2F-链表中去重"><a href="#有序数组-x2F-链表中去重" class="headerlink" title="有序数组&#x2F;链表中去重"></a>有序数组&#x2F;链表中去重</h6><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/title1.png"><p>把 <code>nums</code> 中所有值为 <code>val</code> 的元素原地删除，依然需要使用快慢指针技巧：</p><p>如果 <code>fast</code> 遇到值为 <code>val</code> 的元素，则直接跳过，否则就赋值给 <code>slow</code> 指针，并让 <code>slow</code>前进一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>,slow =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast] != val)&#123;<br>            nums[slow] = nums[fast];<br>            slow++;<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>将数组中的所有值为 0 的元素移到数组末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-comment">//去除 nums 中的所有 0，返回不含 0 的数组长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> removeElement(nums,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 将 nums[p..] 的元素赋值为 0</span><br>    <span class="hljs-keyword">for</span>(;p&lt;nums.length;p++)&#123;<br>        nums[p] =<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-secondary"> <em>滑动窗口算法框架</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">slidingWindow</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s,<span class="hljs-built_in">string</span> t)</span>&#123;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; nedd,window;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: t)&#123;<br>        need[c]++;<br>    &#125;<br>    <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> valid =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(right &lt; s.size())&#123;<br>        <span class="hljs-type">char</span> c = s[right];<br>        <span class="hljs-comment">//右移（增大）窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        <br>        <span class="hljs-keyword">while</span>(window needs shrink)&#123;<br>            <span class="hljs-type">char</span> d = s[left];<br>             <span class="hljs-comment">// 左移（缩小）窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-secondary"> <em>左右指针的常用算法</em></p><h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><p>最简单的二分算法，旨在突出它的双指针特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid +<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h6><p>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 <code>left</code> 和 <code>right</code> 就可以调整 <code>sum</code> 的大小：<br><img src="https://labuladong.github.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/title.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)&#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right =nums.length -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            <span class="hljs-comment">// 题目要求的索引是从 1 开始的</span><br>            <span class="hljs-keyword">return</span> nwe <span class="hljs-type">int</span>[]&#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>            left++; <span class="hljs-comment">//让 sum 大一点</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            right--; <span class="hljs-comment">//让 sum 小一点</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span>&#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = s.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-comment">// 交换 s[left] 和 s[right]</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>        s[left] = s[right];<br>        s[right] = temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span>&#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>,right = s.length()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;<br>            <span class="hljs-keyword">return</span> fasle;<br>        &#125;<br>        left++;<br>        right--;<br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>找出最长的回文串</strong><br><img src="https://labuladong.github.io/algo/images/%e5%9b%9e%e6%96%87/title.png"><br>核心是<strong>从中心向两端扩散的双指针技巧</strong><br>如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符。所以我们可以先实现这样一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span><br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span> &amp;&amp; r &lt; s.lenth() &amp;&amp; s.charAt(l) == s.charAt(r))&#123;<br>     <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--;<br>        r++;<br>    &#125; <br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l+<span class="hljs-number">1</span>,r);  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最长回文串的问题，解法的大致思路就是：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= i &lt; len(s):<br>找到以 s[i] 为中心的回文串<br>找到以 s[i] 和 s[i+<span class="hljs-number">1</span>] 为中心的回文串<br><br>String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">// 以 s[i] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> palindrome(s, i, i);<br>        <span class="hljs-comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> palindrome(s, i, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// res = longest(res, s1, s2)</span><br>        res = res.length() &gt; s1.length() ? res : s1;<br>        res = res.length() &gt; s2.length() ? res : s2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></div>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表算法技巧</title>
    <link href="/2023/02/08/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/02/08/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><p class="note note-danger"> <em>认识链表</em></p><p>目前正在 <span class="label label-primary">labuladong</span>的网站下学习数据结构和算法 <strong>————</strong> 链表。<br>通过博主的介绍让我感觉算法没有以前难学了。</p><p><a class="btn" href="https://labuladong.github.io/algo/">博客</a></p><p class="note note-danger"> <em>合并两个有序链表</em> </p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title.jpg"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1,ListNode l2)</span>&#123;<br>    <span class="hljs-comment">//虚拟头节点   哨兵</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>),p = dummy;<br>    <span class="hljs-comment">//链表头指向 p1 , p2</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> l1,p2 = l2;<br>    <br>    <span class="hljs-comment">//判断链表是否遍历完成</span><br>    <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">null</span> &amp;&amp; p2 != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//比较 p1 p2 的值 ，将小的值接到 p 的下边</span><br>        <span class="hljs-keyword">if</span>(p1.val &gt; p2.val)&#123;<br>            p.next = p2;<br>            p2 = p2.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p.next = p1;<br>            p1 = p1.next;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//最后判断链表是否有剩余,剩余的直接放到 P 后边</span><br>    <span class="hljs-keyword">if</span>(p1 != <span class="hljs-literal">null</span>)&#123;<br>        p.next = p1;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p2 != <span class="hljs-literal">null</span>)&#123;<br>        p.next = p2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>while 循环每次比较 <code>p1</code> 和 <code>p2</code> 的大小，把较小的节点接到结果链表<br><img src="https://labuladong.github.io/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/1.gif"></p><p class="note note-danger"> <em>链表的分解</em> </p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title4.jpg"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">parition</span><span class="hljs-params">(ListNode head,<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-comment">//存放小于 x 的链表的虚拟头节点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//存放大于 x 的链表的虚拟头节点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//p1 p2 指针负责生成结果链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> dummy1,p2 = dummy2;<br>    <span class="hljs-comment">//p 负责遍历原链表，类似合并两个有序链表的逻辑</span><br>    <span class="hljs-comment">//这里将一个链表分解成两个链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p.val &gt;= x)&#123;<br>            p2.next = p;<br>            p2 = p2.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p1.next = p;<br>            p1 = p1.next;<br>        &#125;<br>        <span class="hljs-comment">//断开原链表中的每个节点的next指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> p.next;<br>        p.next = <span class="hljs-literal">null</span>;<br>        p = temp;<br>    &#125; <br>    <span class="hljs-comment">//连接两个链表</span><br>    p1.next = dummy2.next;<br>    <span class="hljs-keyword">return</span> dummy1.next;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-danger"> <em>合并 <span class="label label-primary">k</span> 个有序链表</em> </p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title2.jpg"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span>&#123;<br>    <span class="hljs-keyword">if</span>(lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//虚拟头节点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-comment">//优先级队列 ，最小堆</span><br>    PrioriyQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrioriyQueue</span>&lt;&gt;(<br>        lists.length,(a,b)-&gt;(a.val - b.val)<br>    );<br>    <br>    <span class="hljs-comment">//将K个链表的头节点加入最小堆</span><br>    <span class="hljs-keyword">for</span>(ListNode head : lists)&#123;<br>        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">null</span>)<br>            pq.add(head);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(!pq.isEmpty)&#123;<br>        <span class="hljs-comment">//获取最小节点，接到结果链表中</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> pq.poll();<br>        p.next = node;<br>        <span class="hljs-keyword">if</span>(node.next != <span class="hljs-literal">null</span>)&#123;<br>            pq.add(node.next);<br>        &#125;<br>        <span class="hljs-comment">//p 指针不断向前</span><br>        p = p.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-danger"> <em>寻找单链表的倒数第 <span class="label label-primary">k</span> 个节点</em> </p><p>首先，我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步：</p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.jpeg"><p>现在的  <code>p1</code> ，只要再走  <code>n - k</code> 步，就能走到链表末尾的空指针</p><p>趁这个时候，再用一个指针 <code>p2</code> 指向链表头节点 <code>head</code>：</p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/2.jpeg"><p>接下来就很显然了，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时前进了 <code>n - k</code> 步，<code>p2</code> 也从 head 开始前进了 <code>n - k</code> 步，停留在第 <code>n - k + 1</code> 个节点上，即恰好停链表的倒数第 <code>k</code> 个节点上：</p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/3.jpeg"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">findFromEnd</span><span class="hljs-params">(ListNode head,<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">//p1 先走 K 步</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// p1 p2 同时走 n-k 步</span><br>    <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">null</span>)&#123;<br>        p2 = p2.next;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span><br>    <span class="hljs-keyword">return</span> p2;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除链表倒数第 <code>N</code> 个节点</strong><br><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title3.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head ,<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-comment">// 虚拟头</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <br>     <span class="hljs-comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> findFromEnd(dummy , n+<span class="hljs-number">1</span>);<br>     <br>     <span class="hljs-comment">//删掉倒数第 n 个节点</span><br>    x.next = x.next.next;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findFromEnd</span><span class="hljs-params">(ListNode head,<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> head;<br>    <br>    <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">null</span>)&#123;<br>        p2 = p2.next;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p2;   <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-danger"> <em>寻找单链表的中点</em> </p><p>用<code>快慢指针</code>技巧：<br>我们让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点 head。<br>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow </code>就指向了链表中点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head,fast = head;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步</span><br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-comment">// 慢指针指向中点</span><br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p><p class="note note-danger"> <em>判断单链表是否包含环并找出环起点</em> </p><p>用<code>快慢指针</code>技巧：<br>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。<br>如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast</code> 最终和 <code>slow</code> 相遇，那肯定是 <code>fast</code> 超过了 <code>slow</code> 一圈，说明链表中含有环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>        <br>        <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果链表中含有环，如何计算这个环的起点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span>head ,slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span>(fast == slow )&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重新指向头结点</span><br>    slow = head;<br>    <span class="hljs-comment">// 快慢指针同步前进，相交点就是环起点</span><br>    <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>快慢指针相遇时，慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：<br><img src="https://labuladong.github.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/3.jpeg"></p><p><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步其实就是 <code>fast</code> 指针在环里转圈圈，所以 <code>k</code> 的值就是环长度的「整数倍」。</p><p>假设相遇点距环的起点的距离为 <code>m</code>，那么结合上图的 <code>slow</code> 指针，环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p><p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。因为结合上图的 <code>fast</code> 指针，从相遇点开始走k步可以转回到相遇点，那走 <code>k - m</code> 步肯定就走到环起点了：<br><img src="https://labuladong.github.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/2.jpeg"></p><p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点了。</p><p class="note note-danger"> <em>判断两个单链表是否相交并找出交点</em> </p>两个链表的头结点 headA 和 headB，这两个链表可能存在相交。如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。<img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/4.png"><p><strong>只使用两个指针，思路：</strong><br><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/5.jpeg"><br><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/6.jpeg"></p><p>解决这个问题的关键是，通过某些方式，让 <code>p1</code> 和 <code>p2</code> 能够同时到达相交节点 <code>c1</code>。</p><p>所以，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p><p>如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">方法一：<br>ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA,ListNode headB)</span>&#123;<br>    <span class="hljs-comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA , p2 = headB;<br>    <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>        <span class="hljs-comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span><br>        <span class="hljs-keyword">if</span>(p1 == <span class="hljs-literal">null</span> ) p1 = headB;<br>        <span class="hljs-keyword">else</span>            p1 = p1.next;<br>        <br>        <span class="hljs-comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span><br>        <span class="hljs-keyword">if</span>(p2 == <span class="hljs-literal">null</span>) p2 = headA;<br>        <span class="hljs-keyword">else</span>           p2 = p2.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br>方法二：<br>ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA,ListNode headB)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//计算两条链表的长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA;p1!=<span class="hljs-literal">null</span>;p1=p1.next)&#123;<br>        lenA++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> headB;p2!=<span class="hljs-literal">null</span>;p2=p2.next)&#123;<br>        lenB++;<br>    &#125;<br>    <span class="hljs-comment">//让 p1 和 p2 到达尾部的距离相同</span><br>    ListNode p1=headA,p2=headB;<br>    is(lenA &gt;lenB)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lenA-lenB;i++)&#123;<br>            p1 = p1.next; <br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lenB-lenA;i++)&#123;<br>            p2 = p2.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 看两个指针是否会相同，p1 == p2 时有两种情况：</span><br>    <span class="hljs-comment">// 1、要么是两条链表不相交，他俩同时走到尾部空指针</span><br>    <span class="hljs-comment">// 2、要么是两条链表相交，他俩走到两条链表的相交点</span><br>    <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>        p1 = p1.next;<br>        p2 = p2.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法核心认识</title>
    <link href="/2023/02/07/%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E8%AE%A4%E8%AF%86/"/>
    <url>/2023/02/07/%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><p class="note note-light"> <em>框架思维</em></p><p>目前正在 <span class="label label-primary">labuladong</span>的网站下学习数据结构和算法。<br>通过博主的介绍让我感觉算法没有以前难学了。</p><p><a class="btn" href="https://labuladong.github.io/algo/">博客</a></p><p class="note note-light"> <em>数据结构的存储方式</em> </p><p>数据结构的存储只有两种：<strong>数组（顺序存储）和链表（链式存储）</strong>。<br>其它的数据结构都是在这基础上进行的实现。</p><p class="note note-light"> <em>数据结构的基本操作</em></p><p>对于任何数据结构，都是<strong>遍历和访问</strong>。</p><h5 id="数组遍历，线性迭代结构："><a href="#数组遍历，线性迭代结构：" class="headerlink" title="数组遍历，线性迭代结构："></a>数组遍历，线性迭代结构：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>        <span class="hljs-comment">//迭代访问</span><br>        arr[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="链表遍历，迭代和递归："><a href="#链表遍历，迭代和递归：" class="headerlink" title="链表遍历，迭代和递归："></a>链表遍历，迭代和递归：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基本的单链表节点 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-keyword">for</span>(ListNode p=head;p!=<span class="hljs-literal">null</span>;p=p.next)&#123;<br>        <span class="hljs-comment">//迭代访问</span><br>        p.val<br>    &#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">treavers</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-comment">//递归访问</span><br>    treavers(head.next)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉树遍历框架，非线性递归遍历："><a href="#二叉树遍历框架，非线性递归遍历：" class="headerlink" title="二叉树遍历框架，非线性递归遍历："></a>二叉树遍历框架，非线性递归遍历：</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/* 基本的二叉树节点 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left,right;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">treavers</span><span class="hljs-params">(ListNode root)</span>&#123;<br>    <span class="hljs-comment">//递归访问</span><br>    treavers(root.left);<br>    treavers(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二叉树框架可以扩展位N叉树的遍历框架</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基本的N叉树节点 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode[] children;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">for</span>(TreeNode child:root.children)&#123;<br>        traverse(child);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-light"> <em>算法学习阶段</em></p><h5 id="1-先学习数组、链表这种基本数据结构："><a href="#1-先学习数组、链表这种基本数据结构：" class="headerlink" title="1.先学习数组、链表这种基本数据结构："></a>1.先学习数组、链表这种基本数据结构：</h5><p>单链表反转、前缀和数组、二分搜索等。</p><h5 id="2-学会基础算法后，在学习二叉树："><a href="#2-学会基础算法后，在学习二叉树：" class="headerlink" title="2.学会基础算法后，在学习二叉树："></a>2.学会基础算法后，在学习二叉树：</h5><p>为什么要先刷二叉树呢，因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 前序位置</span><br>    traverse(root.left);<br>    <span class="hljs-comment">// 中序位置</span><br>    traverse(root.right);<br>    <span class="hljs-comment">// 后序位置</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="求二叉树中最大路径和："><a href="#求二叉树中最大路径和：" class="headerlink" title="求二叉树中最大路径和："></a>求二叉树中最大路径和：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><span class="hljs-type">int</span> <span class="hljs-title function_">oneSideMax</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> max (<span class="hljs-number">0</span>,oneSideMax(root.left));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> max(<span class="hljs-number">0</span>,oneSideMax(root.right));<br>    <br>    <span class="hljs-comment">//后序位置</span><br>    res = Math.max(res.left+right+root.val);<br>    <span class="hljs-keyword">return</span> Maht.max(left,right)+root.val;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：后序遍历</strong></p><h6 id="前序遍历和中序遍历的结果还原一棵二叉树："><a href="#前序遍历和中序遍历的结果还原一棵二叉树：" class="headerlink" title="前序遍历和中序遍历的结果还原一棵二叉树："></a>前序遍历和中序遍历的结果还原一棵二叉树：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, </span><br><span class="hljs-params">               <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> &#123;<br>    <span class="hljs-comment">//前序遍历，寻找左右子树的节点</span><br>    <span class="hljs-keyword">if</span>(preStart &gt; preEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preStart];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=inStart; i&lt;= inEnd;i++)&#123;<br>        <span class="hljs-keyword">if</span>(inorder[i] == rootVal)&#123;<br>            index = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> index - inStart;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>    <span class="hljs-comment">// 递归构造左右子树</span><br>    root.left = build(preorder, preStart+<span class="hljs-number">1</span>,        preStart + leftSize,<br>                        inorder,inStart,index -<span class="hljs-number">1</span>)<br>    root.right = build(preorder,preStart+leftSize+<span class="hljs-number">1</span>,preEnd,<br>                        inorder,index +<span class="hljs-number">1</span>  ,inEnd)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：参数只是控制数组索引</strong></p><h6 id="寻找二叉搜索树中的第-k-小的元素："><a href="#寻找二叉搜索树中的第-k-小的元素：" class="headerlink" title="寻找二叉搜索树中的第 k 小的元素："></a>寻找二叉搜索树中的第 <code>k</code> 小的元素：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    traverse(root.left,k);<br>    <span class="hljs-comment">/* 中序遍历位置 */</span><br>    rank++;<br>    <span class="hljs-keyword">if</span>(k == rank)&#123;<br>        res = root.val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/*******************/</span><br>    traverse(root.right,k);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：中序遍历</strong></p><h6 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h6><img src="https://labuladong.github.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/5.jpg"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins,<span class="hljs-type">int</span> amount)</span>&#123;<br>    <span class="hljs-keyword">if</span>(amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> coin : coins)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subProblem</span> <span class="hljs-operator">=</span> dp(coins,amount - coin);<br>        <span class="hljs-comment">// 子问题无解则跳过</span><br>        <span class="hljs-keyword">if</span>(subProblem == -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 在子问题中选择最优解，然后加一</span><br>        res = Math.min(res.subProblem +<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? -<span class="hljs-number">1</span>: res;<br>&#125;<br><span class="hljs-comment">/* 代码简化 遍历N叉树问题 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> coin:coins)&#123;<br>        dp(coins,amount - coin);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：暴力解法就是遍历一棵 N 叉树</strong></p><h6 id="凑零钱问题-1"><a href="#凑零钱问题-1" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h6><img src="https://labuladong.github.io/algo/images/backtracking/1.jpg"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,LinkedList&lt;Integer&gt; track )</span>&#123;<br>    <span class="hljs-keyword">if</span>(track.size() == nums.length)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(track.contains(nums[i]))&#123;<br>            constinue;<br>        &#125;<br>        track.add(nums[i]);<br>         <span class="hljs-comment">// 进入下一层决策树</span><br>         backtrack(nums,track);<br>         track.removeLst();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 简化代码  提取出 N 叉树遍历框架*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        backtrack(nums, track);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-light"> <em>总结</em></p><p>学习算法，要从整体出发。建立对数据结构和算法的一个框架性的认识。<br><code>只要涉及递归的问题，都是树的问题</code></p></div>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试讲座[一]</title>
    <link href="/2023/02/03/%E9%9D%A2%E8%AF%95%E8%AE%B2%E5%BA%A7/"/>
    <url>/2023/02/03/%E9%9D%A2%E8%AF%95%E8%AE%B2%E5%BA%A7/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><p class="note note-primary"> 如何让你的简历更受青睐</p><h5 id="内容上，要恰当地结构化，详略得当，层次有序。"><a href="#内容上，要恰当地结构化，详略得当，层次有序。" class="headerlink" title="内容上，要恰当地结构化，详略得当，层次有序。"></a>内容上，要恰当地结构化，详略得当，层次有序。</h5><p>简历中最重要的内容是：技能和项目经历。</p><h5 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h5><p>需要按照领域分类，以列表的形式呈现在简历里。同时，要标明技能等级。等级可以用“精通”“熟练”等词标识，或者用工作年数标识。把最对口、最熟练的技能往前放。那些只是了解，还没有使用过的技能，可以不列，否则面试的时候被问到也很尴尬。</p><h5 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h5><p>体现你的工作资历和能力价值。每一段项目经历，都有其独特性，都有价值点可挖。但是，很多简历这块并没有写好。我总结出下面一种写法，如下图所示，供你参考。</p><img src="https://static001.geekbang.org/resource/image/cd/97/cd31612a4e3a2de3c229f101b79e5497.png?wh=913*469">&nbsp;&nbsp;<p>在撰写经历的时候，要注意详略得当。为了突出有价值的内容，简历篇幅尽量控制在 2 页以内，别让太多内容干扰了面试官的视线。这就要舍得删减。什么内容可以删减呢？</p><ul><li>如果已经有了高级的技能，同类技能中低级的部分就不用写了。</li><li>重复技能的经历，尽量找出不同点用一句话概括。</li><li>职位描述中没提到的技能，可以删。即使不删，也不要喧宾夺主。简历上的技能列表并非越长越好。</li><li>如果已经有正式的工作经历，那么表现平平的实习经历可以删，除非像某位苹果实习生一样设计出了 MacBook 键盘。</li><li>如果有耀眼的成果，那么描述性的工作过程可以删。</li><li>千篇一律的自评可以删，前面说过，面试官不会拿你的自评太当真。</li></ul><p><strong>形式上，要简洁大方、重点突出，从视觉上，引导对方关注你最想表达的部分。</strong></p><p class="note note-secondary">如何让你的简历“没硬伤”？</p><p>没硬伤”是指简历没有显著的问题。这里有一些常见的毛病，可能是很多人会犯的。</p><ol><li>内容不真实。</li><li>内容不客观，掺杂主观臆断。</li><li>页面太花哨。</li><li>笔误。</li><li>内容导致歧义或误解。</li><li>职业发展不衔接。</li><li>换工作太频繁。</li></ol><p class="note note-success">总结</p><p>写好简历，需要准确把握职位要求，挖掘个人的经历，从而做到：有价值、易匹配、没硬伤、有亮点。</p></div>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/01/hello-world/"/>
    <url>/2023/02/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="hexo-new-page-p-about-x2F-me-“About-me”"><a href="#hexo-new-page-p-about-x2F-me-“About-me”" class="headerlink" title="hexo new page -p about&#x2F;me “About me”"></a>hexo new page -p about&#x2F;me “About me”</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
